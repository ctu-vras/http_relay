#!/usr/bin/env python

"""
Relay HTTP get requests from localhost to a remote host (act as reverse HTTP proxy).

ROS parameters:
- ~host (mandatory): The remote host to connect to (e.f. "ntrip.pecny.cz").
- ~port (mandatory): The remote host's port to connect to.
- ~local_port (default: ~port): The localhost port to be used for the relay.
- ~num_threads (default: 8 threads): Number of threads servicing the incoming requests.
- ~buffer_size (default: 1 byte): Size of the buffer used for reading responses. Generally, a larger buffer should be
                                  more efficient, but if it is too large, the local clients may time out before they
                                  receive any data.

SPDX-License-Identifier: BSD-3-Clause
SPDX-FileCopyrightText: Czech Technical University in Prague
"""

import errno
import socket
import sys
import threading

import rospy

try:
    from http.server import HTTPServer, BaseHTTPRequestHandler
    from http.client import HTTPConnection
except ImportError:
    from SimpleHTTPServer import HTTPServer, BaseHTTPRequestHandler
    from httplib import HTTPConnection

request_num = 0


class HTTP10Connection(HTTPConnection):
    _http_vsn_str = "HTTP/1.0"
    _http_vsn = 10


class HTTP11Connection(HTTPConnection):
    _http_vsn_str = "HTTP/1.1"
    _http_vsn = 11


class Handler(BaseHTTPRequestHandler):
    """
    The main logic of the relay - forward the HTTP request to the remote server with changed Host: header and pass back
    whatever it returns.
    """
    host = "localhost"
    port = 80
    read_buffer_size = 1

    def __init__(self, request, client_address, server):
        global request_num
        self._req_num = request_num
        request_num += 1
        try:
            BaseHTTPRequestHandler.__init__(self, request, client_address, server)
        except socket.error as e:
            self.log_socket_error(e)

    # Do not log requests using the BaseHTTPRequestHandler logging mechanism, we have our own.
    def log_request(self, code='-', size='-'):
        pass

    def log_error(self, format, *args):
        """
        Log an error message.
        :param str format: Format string.
        :param List[Any] args: % parameters of the format string.
        """
        if rospy.is_shutdown():
            pass
        rospy.logerr(("Request [%i] error: " + format) % tuple([self._req_num] + list(*args)))

    def log_socket_error(self, e):
        """
        Log an error raised by socket operation.
        :param socket.error e: The error.
        """
        # Ignore EPIPE and ECONNRESET as that is generated when the other end stops being interested in our data
        if isinstance(e, tuple) and e[0] in (errno.EPIPE, errno.ECONNRESET):
            rospy.loginfo("Response [%i]: finished" % (self._req_num,))
        elif ("Errno %i" % (errno.EPIPE,)) in str(e) or ("Errno %i" % (errno.ECONNRESET,)) in str(e):
            rospy.loginfo("Response [%i]: finished" % (self._req_num,))
        else:
            self.log_error("%s", str(e))

    def log_message(self, format, *args):
        """
        Log an info message.
        :param str format: Format string.
        :param List[Any] args: % parameters of the format string.
        """
        if rospy.is_shutdown():
            pass
        rospy.loginfo(("Request [%i]: " + format) % tuple([self._req_num] + list(*args)))

    def log_response(self, format, *args):
        """
        Log an info message related to the response.
        :param str format: Format string.
        :param List[Any] args: % parameters of the format string.
        """
        if rospy.is_shutdown():
            pass
        rospy.loginfo(("Response [%i]: " + format) % tuple([self._req_num] + list(*args)))

    def do_GET(self):
        """
        Do the relaying work.
        """
        try:
            # Choose the right HTTP version
            connection_class = HTTP11Connection if self.protocol_version == "HTTP/1.1" else HTTP10Connection
            conn = connection_class(Handler.host, Handler.port)

            # Forward the request with the same headers
            headers = dict(zip(self.headers.keys(), self.headers.values()))
            self.log_message("GET http://%s:%i%s", (Handler.host, Handler.port, self.path))
            conn.request("GET", self.path, headers=headers)

            # Obtain the response
            resp = conn.getresponse()
            self.send_response(resp.status)
            self.log_response("%i %s", (resp.status, resp.reason))

            # Forward back the response headers
            for header, value in resp.getheaders():
                self.send_header(header, value)
            self.end_headers()

            # Forward back the response body
            num_bytes = 0
            while not rospy.is_shutdown():
                chunk = resp.read(Handler.read_buffer_size)
                if not chunk:
                    self.log_response("finished", ())
                    break
                self.wfile.write(chunk)
                num_bytes += Handler.read_buffer_size
                if num_bytes > 10 * Handler.read_buffer_size:
                    rospy.logdebug_throttle(1.0, "Response body [%i]: Sent %i bytes." % (self._req_num, num_bytes))
        except socket.error as e:
            self.log_socket_error(e)
        except Exception as e:
            self.log_error("%s", str(e))


class Thread(threading.Thread):
    """
    The HTTP server servicing thread.
    """

    def __init__(self, server):
        """
        Create and run the servicing thread.
        :param HTTPServer server: The server to work with.
        """
        threading.Thread.__init__(self)
        self.server = server
        self.daemon = True
        self.start()

    def run(self):
        """
        Process the server requests.
        """
        while not rospy.is_shutdown():
            try:
                self.server.serve_forever()
            except Exception as e:
                if not rospy.is_shutdown():
                    rospy.logerr("Error in processing thread: " + str(e))


def run(relay_port, remote_host, remote_port, num_threads, buffer_size):
    """
    Run the multithreaded relay server.
    :param int relay_port: The local port.
    :param str remote_host: The remote host name.
    :param int remote_port: The remote host port.
    :param int num_threads: Number of servicing threads.
    :param int buffer_size: Size of the buffer used for reading responses. If too large, the forwarding can be too slow.
    """
    server_address = ('', relay_port)
    Handler.host = remote_host
    Handler.port = remote_port
    Handler.read_buffer_size = buffer_size

    try:
        # Create a standalone socket shared by all servers
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(server_address)
        sock.listen(5)

        # Create the servers and run their servicing threads
        servers = []
        threads = []
        for i in range(num_threads):
            httpd = HTTPServer(server_address, Handler, False)
            httpd.socket = sock
            httpd.server_bind = httpd.server_close = lambda self: None
            servers.append(httpd)
            threads.append(Thread(httpd))

        # Wait for node exit
        try:
            rospy.spin()
        except rospy.ROSInterruptException:
            pass

        # First, shut down the socket, which should convince server.shutdown() to finish.
        sock.shutdown(socket.SHUT_RDWR)
        sock.close()

        # Shut down the servers (their service threads are daemons, so we don't need to join them)
        for server in servers:
            if server is not None:
                server.shutdown()

    except socket.gaierror as e:
        if not rospy.is_shutdown():
            rospy.logerr(str(e))
        sys.exit(2)
    except socket.error as e:
        if not rospy.is_shutdown():
            rospy.logerr(str(e))
        sys.exit(1)


def main():
    rospy.init_node("http_relay")

    host = rospy.get_param("~host")  # e.g. "ntrip.pecny.cz"
    port = rospy.get_param("~port")  # e.g. 2021
    local_port = rospy.get_param("~local_port", port)  # The localhost port used for the relay
    num_threads = rospy.get_param("~num_threads", 8)  # Number of servicing threads
    buffer_size = rospy.get_param("~buffer_size", 1)  # Size of the buffer used for reading responses

    rospy.loginfo("Relaying HTTP requests from %s:%i to %s:%i using %i threads" % (
        "localhost", local_port, host, port, num_threads))

    run(local_port, host, port, num_threads, buffer_size)


if __name__ == '__main__':
    main()
